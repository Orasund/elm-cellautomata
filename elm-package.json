[{"name":"CellAutomata.LifeLike","comment":" \r\n#What is a Cell Automata?\r\nThe most famous cell automata is Conway's Game of Life.\r\na cell automata takes the state of a cell as well as the state of its neighbors\r\nand then calculate the new state of the cell.\r\n\r\n#Where are Cell Automatas used?\r\nThenever something is dynamically generated in a game, it most often has an underlying cell automata.\r\nThere are a few nice automatas for building landscapes or dungeons,\r\nbut this documentation we will mostly focus on famous mathematical automatas.\r\n\r\n\r\nIf you want to create a si\r\nThis module was created to give a smooth introduction to the main module,\r\nbut also because for a lot of usecases this simpler version is already enough.\r\n\r\nIn this module, a few assumptions about the automata where made:\r\n* The cells are organiced in a two dimensional grid.\r\n* Each cell can have on of two states: Dead(Nothing) or Alive(Just Alive)\r\n* Each cell has Eight neighbors\r\n* A Rule can only take the amount of alive neighbored cells into account. (Not the pattern)\r\n*Note for the advanced:* This last assumption can be ignored by using\r\nthe automataWithoutSymmetry(the exact pattern must the matched) \r\nor automataWithCustomSymmetry(for example mirrored or rotational symmetry).\r\n\r\n## Basic types\r\n@docs Grid,State,Location\r\n\r\n## Automata\r\n@docs AliveNeighbors,step,Automata,automata\r\n\r\n# For the Advanced\r\nThe remaining documentation is for more advanced user.\r\nUp until now only the amound of living neighbors where important, but not their position.\r\n\r\nAs an example, we want to now modify conway's game of live, such that only the four direct\r\nneighbors (North,South,East,West) are considered.\r\n\r\n## Rule\r\n@docs RuleExpression,Neighborhood,anyNeigborhood,Rule\r\n\r\n## Advanced Automata\r\n@docs automataWithoutSymmetry\r\n\r\n##Custom Symmetry\r\n@docs Symmetry,fullSymmetry,noSymmetry,rot90Symmetry,automataWithCustomSymmetry\r\n","unions":[{"name":"AliveNeighbors","comment":" This type specifies how many neighbors may be alive.\r\n","args":[],"cases":[]},{"name":"RuleExpression","comment":" RuleExpression give us a very flexible way of talking about neighbors.\r\nWhen writing a Rule for the neighbors, they can now have one of the follow values:\r\n* *(Exactly <| Just Alive)* - its alive\r\n* *(Exactly <| Nothing)* - its dead\r\n* *Anything* - it may be dead or alive - we dont care.\r\n\r\n*Note:*\r\nIf you would go back to counting the alive neighbors, the anything-expression will\r\nact like an optional neighbor.\r\nFor example a rule that looks for 3 alive neighbors and 2 anything,\r\nits will be successfull if it finds either 3,4 or 5 alive neighbors.\r\n","args":["state"],"cases":[]},{"name":"State","comment":" The type of a cell will be of (Maybe State). This is to make clear, that\r\nIf not specified otherwise, a cell will be \"Nothing\".\r\nIn this module there is just one other state: \"Alive\".\r\nIf you want to add more states, then this you should go to the main module.\r\n","args":[],"cases":[["Alive",[]]]}],"aliases":[{"name":"Automata","comment":" the type for an Automata\r\n","args":[],"type":"CellAutomata.Automata (CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State)) (CellAutomata.LifeLike.Neighborhood (CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State))) CellAutomata.LifeLike.Location CellAutomata.LifeLike.State"},{"name":"Grid","comment":" The grid is the \"model\" of this module. You might want to write your own view function\r\nfor it or else you can't see what the automata has done.\r\n\r\nIn your head you should think of this as a grid, there some cells may be filled.\r\nFilled cells have the value \"Just Alive\" while empty cells have the value \"Nothing\".\r\nThis is why we can represent the grid as a dictionary.\r\n","args":[],"type":"Dict.Dict CellAutomata.LifeLike.Location CellAutomata.LifeLike.State"},{"name":"Location","comment":" The location is the unique identifier for any cell.\r\nFor our purpose we use (x,y)-coordinates.\r\n\r\n*Note for the advanced:* The south of (0,0) is (0,y) while the north is (0,-y).\r\nThis might be of inportance as soon as you start playing around with symmetries.\r\n","args":[],"type":"( Basics.Int, Basics.Int )"},{"name":"Neighborhood","comment":" Instead of saying \"one alive neighbor\", we now need to explicitly specify where\r\nthis neighbor is located.\r\n\r\nIf not every neighbor must have an explicit value(that is most often the case),\r\nits best to use the anyNeighborhood template and start from there.\r\n","args":["state"],"type":"{ north : state, northEast : state, east : state, southEast : state, south : state, southWest : state, west : state, northWest : state }"},{"name":"Rule","comment":" A rule now needs a Neighborhood instead of an AliveNeighbors-value.\r\n","args":[],"type":"{ from : Maybe.Maybe CellAutomata.LifeLike.State, neighbors : CellAutomata.LifeLike.Neighborhood (CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State)), to : Maybe.Maybe CellAutomata.LifeLike.State }"},{"name":"Symmetry","comment":" A symmetry is just a function that determines when a rule is sucessfully applied.\r\nDuring this documentation we have already encountered two different symmetries:\r\nfullSymmetry and noSymmetry.\r\n\r\nThis module does also include rot90Symmetry(rotation by 90 degrees).\r\n","args":[],"type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"}],"values":[{"name":"anyNeigborhood","comment":" this template helps defining a Neighborhood.\r\n\r\nFor example, if we would want to only consider the 4 adjacent neighbors,\r\nwe might specify it the following way\r\n    {anyNeighborhood\r\n    | north : Exactly a\r\n    , east : Exactly b\r\n    , south : Exactly c\r\n    , west : Exactly d\r\n    }\r\n","type":"{ north : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), northEast : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), east : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), southEast : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), south : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), southWest : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), west : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), northWest : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State) }"},{"name":"automata","comment":" The Automata type can be seen as a config type.\r\nIts stores all information to specify the behaviour of a cell automata.\r\nSometimes more then one automata should act on to the same Grid.\r\nFor this reason it is its own type.\r\n\r\nThe input is a list of rules.\r\nAs an example, lets look at the rules for conway's game of life:\r\n* Alive cells survive if they have 2 or 3 alive neighbors, else they die.\r\n* Dead cells turn alive if exactly 3 neighbors are alive\r\nimplemented, these rules look like this:\r\n    [ {from = Just Alive, neighbors = TwoAlive, to = Just Alive}\r\n    , {from = Just Alive, neighbors = ThreeAlive, to = Just Alive}\r\n    , {from = Just Alive, neighbors = AnyAmount, to = Nothing}\r\n    , {from = Nothing, neighbors = ThreeAlive, to = Just Alive}\r\n    ]\r\nThe order of the rules are important: the automata will go through the list,\r\nand use the first use it can apply.\r\n","type":"List.List { from : Maybe.Maybe CellAutomata.LifeLike.State, neighbors : CellAutomata.LifeLike.AliveNeighbors, to : Maybe.Maybe CellAutomata.LifeLike.State } -> CellAutomata.LifeLike.Automata"},{"name":"automataWithCustomSymmetry","comment":" With this function we can now add our own symmetry.\r\n\r\ngoing back to the old example, where we tryed to implement our variant,\r\nthis can now be done the following way:\r\n    [ {from = Just Alive\r\n      , to = Just Alive\r\n      , neighbors = neighbors (Just Alive) Nothing Nothing Nothing\r\n      }\r\n    , {from = Just Alive, to = Nothing, neighbors = anyNeighborhood}\r\n    , {from = Nothing\r\n      , to = Just Alive\r\n      , neighbors = neighbors (Just Alive) Nothing Nothing Nothing\r\n      }\r\n    ]\r\n        |> automataWithCustomSymmetry rot90Symmetry\r\n","type":"CellAutomata.LifeLike.Symmetry -> List.List CellAutomata.LifeLike.Rule -> CellAutomata.LifeLike.Automata"},{"name":"automataWithoutSymmetry","comment":" this function uses no symmetry, this means every possible combination must be\r\nspecified.\r\n\r\nFor example. Lets say we want to modify conway's game of life, such that\r\nit only considers the four adjacent neighbors:\r\n* Alive cells survive if they have exactly 1 adjacent neighbors\r\n* Dead cells turn alive if exactly 1 neighbors are alive\r\nthe implementation would the the following list:\r\n    let\r\n        neighbors a b c d = \r\n            {anyNeighborhood\r\n            | north : Exactly a\r\n            , east : Exactly b\r\n            , south : Exactly c\r\n            , west : Exactly d\r\n            }\r\n    in\r\n    [ {from = Just Alive\r\n      , to = Just Alive\r\n      , neighbors = neighbors (Just Alive) Nothing Nothing Nothing\r\n      }\r\n    , {from = Just Alive\r\n      , to = Just Alive\r\n      , neighbors = neighbors Nothing (Just Alive) Nothing Nothing\r\n      }\r\n    , {from = Just Alive\r\n      , to = Just Alive\r\n      , neighbors = neighbors Nothing Nothing (Just Alive) Nothing\r\n      }\r\n    , {from = Just Alive\r\n      , to = Just Alive\r\n      , neighbors = neighbors Nothing Nothing Nothing (Just Alive)\r\n      }\r\n    , {from = Just Alive, to = Nothing, neighbors = anyNeighborhood}\r\n    , {from = Nothing\r\n      , to = Just Alive\r\n      , neighbors = neighbors (Just Alive) Nothing Nothing Nothing\r\n      }\r\n    , {from = Nothing\r\n      , to = Just Alive\r\n      , neighbors = neighbors Nothing (Just Alive) Nothing Nothing\r\n      }\r\n    , {from = Nothing\r\n      , to = Just Alive\r\n      , neighbors = neighbors Nothing Nothing (Just Alive) Nothing\r\n      }\r\n    , {from = Nothing\r\n      , to = Just Alive\r\n      , neighbors = neighbors Nothing Nothing Nothing (Just Alive)\r\n      }\r\n    ]\r\nAs one can tell, that example blew up. Thats because we do not use any symmetry.\r\n","type":"List.List CellAutomata.LifeLike.Rule -> CellAutomata.LifeLike.Automata"},{"name":"fullSymmetry","comment":" the position of the neighbors is not important, only the amount.\r\n","type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"},{"name":"noSymmetry","comment":" every possible way the neighbors might be arranged needs its own rule.\r\n","type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"},{"name":"rot90Symmetry","comment":" pattern may be rotated in 90,180 and 270 degree angles.\r\n","type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"},{"name":"step","comment":" This is the main function.\r\nIt has a wierd type, but thats because it is meant to be used with Dict.update:\r\n    List.range 0 12\r\n    |> List.foldl\r\n        (\\x g ->\r\n            List.range 0 10\r\n            |> List.foldl\r\n                (\\y -> Dict.update (x,y) ((x,y) |> step automata grid))\r\n                g\r\n        )\r\n        grid\r\n\r\n    List.range 0 12\r\n    |> List.foldl\r\n        ( Dict.map (step automata grid))\r\n        grid\r\n","type":"CellAutomata.LifeLike.Automata -> CellAutomata.LifeLike.Grid -> CellAutomata.LifeLike.Location -> Maybe.Maybe CellAutomata.LifeLike.State -> Maybe.Maybe CellAutomata.LifeLike.State"}],"binops":[]}]