[{"name":"CellAutomata.LifeLike","comment":" \r\nðŸ”²ðŸ”²ðŸ”´  \r\nðŸ”´ðŸ”²ðŸ”´  \r\nðŸ”²ðŸ”´ðŸ”´  \r\nThis module was created to give a smooth introduction to the main module,  \r\nbut also because for a lot of usecases this simpler version is already enough.\r\n\r\n**If you know of Conway's Game of Life and want to make something similiar,**\r\n**this module is the right one for you**\r\n\r\nIn this module, a few assumptions about the automata where made:\r\n* The cells are organiced in a two dimensional grid.\r\n* Each cell can have on of two states: *Dead*(`Nothing`) or *Alive*(`Just Alive`)\r\n* Each cell has eight neighbors\r\n* A rule can only take the amount of alive neighbored cells into account. (Not the pattern)\r\n\r\n**Note:** This last assumption can be ignored by using\r\n`automataWithoutSymmetry`(the exact pattern must the matched) \r\nor `automataWithCustomSymmetry`(for example mirrored or rotational symmetry).\r\n\r\n# The Basics\r\n## Basic Types\r\n@docs Grid,State,Location\r\n\r\n## Basic Automata\r\n@docs AliveNeighbors,step,Automata,automata\r\n\r\n# Rule Expressions and Symmetries\r\nUp until now, only the amound of living neighbors where important, but not their position.  \r\n\r\nFor the remaining documentation we use a modified version of game of life,  \r\nwhere only the four direct neighbors (North,South,East,West) are considered.  \r\n\r\n## Rule\r\n@docs RuleExpression,Neighborhood,anyNeigborhood,Rule\r\n\r\n## Automata\r\n@docs automataWithoutSymmetry\r\n\r\n##Custom Symmetry\r\n@docs Symmetry,fullSymmetry,noSymmetry,rot90Symmetry,automataWithCustomSymmetry\r\n","unions":[{"name":"AliveNeighbors","comment":" This type specifies how many neighbors may be alive.\r\n","args":[],"cases":[["AllDead",[]],["OneAlive",[]],["TwoAlive",[]],["ThreeAlive",[]],["FourAlive",[]],["FiveAlive",[]],["SixAlive",[]],["SevenAlive",[]],["EightAlive",[]],["AnyAmount",[]]]},{"name":"RuleExpression","comment":" RuleExpressions give us a very flexible way of talking about neighbors.  \r\nWhen writing a rule for the neighbors, they can now have one of the following values:  \r\n* **(Exactly <| Just Alive)** - its alive\r\n* **(Exactly <| Nothing)** - its dead\r\n* **Anything** - it may be dead or alive - we dont care.\r\n\r\n**Note:**\r\nIf you would go back to counting the alive neighbors, the `Anything`-expression will\r\nact like an optional neighbor.  \r\nFor example a rule that looks for 3 `Alive` and 2 `Anything`,  \r\nits will be successfull if it finds either 3,4 or 5 alive neighbors. \r\n","args":["state"],"cases":[]},{"name":"State","comment":" The State will specify all posible states a Cell can be in (besides a empty Cell)\r\n\r\nThis means cells will be of type `Maybe State`.  \r\nThis way its clear that, if not specified otherwise, a cell will be `Nothing`.  \r\nIn this module there is just one other state: `Just Alive`.  \r\nIf you want to add more states, then you should go to the main module.  \r\n","args":[],"cases":[["Alive",[]]]}],"aliases":[{"name":"Automata","comment":" The Automata type can be seen as a config type.  \r\nIts stores all information to specify the behaviour of a cell automata.  \r\nSometimes more then one automata should act on to the same Grid.  \r\nFor this reason it is its own type.\r\n","args":[],"type":"CellAutomata.Automata (CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State)) (CellAutomata.LifeLike.Neighborhood (CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State))) CellAutomata.LifeLike.Location CellAutomata.LifeLike.State"},{"name":"Grid","comment":" The grid is the *model* of this module.\r\n\r\nYou might want to write your own view function for it or else you can't see what the automata has done.\r\n\r\nIn your head you should think of this as a grid, where some cells are filled in.  \r\nIn fact, only the filled cells are stored in the Dict.  \r\nFilled cells have the value `Just Alive` while empty cells have the value `Nothing`.  \r\nThis is why we represent the grid as a dictionary.\r\n","args":[],"type":"Dict.Dict CellAutomata.LifeLike.Location CellAutomata.LifeLike.State"},{"name":"Location","comment":" The location is the unique identifier for any cell.  \r\nFor our purpose we use `(x,y)`-coordinates.  \r\n\r\n**Note:** The south of `(0,0)` is `(0,y)` while the north is `(0,-y)`.\r\n","args":[],"type":"( Basics.Int, Basics.Int )"},{"name":"Neighborhood","comment":" This replaces the `AliveNeighbors` type.  \r\nInstead of saying \"one alive neighbor\", we now need to explicitly specify where\r\nthis neighbor is located.\r\n\r\nIf some neighbor may have any value (that is most often the case),  \r\nits best to use the anyNeighborhood template and start from there.  \r\n","args":["state"],"type":"{ north : state, northEast : state, east : state, southEast : state, south : state, southWest : state, west : state, northWest : state }"},{"name":"Rule","comment":" A rule now needs a Neighborhood instead of an `AliveNeighbors`-value.\r\n","args":[],"type":"{ from : Maybe.Maybe CellAutomata.LifeLike.State, neighbors : CellAutomata.LifeLike.Neighborhood (CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State)), to : Maybe.Maybe CellAutomata.LifeLike.State }"},{"name":"Symmetry","comment":" A symmetry is just a function that determines when a rule is sucessfully applied.  \r\nDuring this documentation we have already encountered two different symmetries:  \r\n`fullSymmetry` and `noSymmetry`.\r\n","args":[],"type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"}],"values":[{"name":"anyNeigborhood","comment":" this template helps defining a Neighborhood.\r\n\r\nFor example, if we would want to only consider the 4 adjacent neighbors,\r\nwe might specify it the following way\r\n\r\n    {anyNeighborhood\r\n    | north : Exactly a\r\n    , east : Exactly b\r\n    , south : Exactly c\r\n    , west : Exactly d\r\n    }\r\n","type":"{ north : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), northEast : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), east : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), southEast : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), south : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), southWest : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), west : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State), northWest : CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State) }"},{"name":"automata","comment":" The input is a list of rules.  \r\nAs an example, lets look at the rules for conway's game of life:\r\n* Alive cells survive if they have 2 or 3 alive neighbors, else they die.\r\n* Dead cells turn alive if exactly 3 neighbors are alive.\r\n\r\nImplemented, these rules look like this:\r\n\r\n    [ {from = Just Alive, neighbors = TwoAlive, to = Just Alive}\r\n    , {from = Just Alive, neighbors = ThreeAlive, to = Just Alive}\r\n    , {from = Just Alive, neighbors = AnyAmount, to = Nothing}\r\n    , {from = Nothing, neighbors = ThreeAlive, to = Just Alive}\r\n    ]\r\n\r\nThe order of the rules are important: the automata will go through the list,  \r\nand use the first use it can apply.\r\n","type":"List.List { from : Maybe.Maybe CellAutomata.LifeLike.State, neighbors : CellAutomata.LifeLike.AliveNeighbors, to : Maybe.Maybe CellAutomata.LifeLike.State } -> CellAutomata.LifeLike.Automata"},{"name":"automataWithCustomSymmetry","comment":" With this function we can now add our own symmetry.\r\n\r\nGoing back to the old example, this can now be done the following way:\r\n\r\n    [ {from = Just Alive\r\n      , to = Just Alive\r\n      , neighbors = neighbors (Just Alive) Nothing Nothing Nothing\r\n      }\r\n    , {from = Just Alive, to = Nothing, neighbors = anyNeighborhood}\r\n    , {from = Nothing\r\n      , to = Just Alive\r\n      , neighbors = neighbors (Just Alive) Nothing Nothing Nothing\r\n      }\r\n    ]\r\n        |> automataWithCustomSymmetry rot90Symmetry\r\n","type":"CellAutomata.LifeLike.Symmetry -> List.List CellAutomata.LifeLike.Rule -> CellAutomata.LifeLike.Automata"},{"name":"automataWithoutSymmetry","comment":" This function uses no symmetry, this means every possible combination must be\r\nspecified.\r\n\r\n    automataWithoutSymmetry = automataWithCustomSymmetry noSymmetry\r\n\r\n**This function is not useful in practice.**  \r\n**Most often you want at least rotational or mirrored symmetry**  \r\n**This function is only included for demonstration purposes**\r\n\r\nFor example, lets say we want to modify conway's game of life, such that\r\nit only considers the four adjacent neighbors:\r\n* Alive cells survive if they have exactly 1 adjacent neighbors\r\n* Dead cells turn alive if exactly 1 neighbors are alive\r\n\r\nThe implementation would be the following list:\r\n\r\n    let\r\n        neighbors a b c d = \r\n            {anyNeighborhood\r\n            | north : Exactly a\r\n            , east : Exactly b\r\n            , south : Exactly c\r\n            , west : Exactly d\r\n            }\r\n    in\r\n    [ {from = Just Alive\r\n      , to = Just Alive\r\n      , neighbors = neighbors (Just Alive) Nothing Nothing Nothing\r\n      }\r\n    , {from = Just Alive\r\n      , to = Just Alive\r\n      , neighbors = neighbors Nothing (Just Alive) Nothing Nothing\r\n      }\r\n    , {from = Just Alive\r\n      , to = Just Alive\r\n      , neighbors = neighbors Nothing Nothing (Just Alive) Nothing\r\n      }\r\n    , {from = Just Alive\r\n      , to = Just Alive\r\n      , neighbors = neighbors Nothing Nothing Nothing (Just Alive)\r\n      }\r\n    , {from = Just Alive, to = Nothing, neighbors = anyNeighborhood}\r\n    , {from = Nothing\r\n      , to = Just Alive\r\n      , neighbors = neighbors (Just Alive) Nothing Nothing Nothing\r\n      }\r\n    , {from = Nothing\r\n      , to = Just Alive\r\n      , neighbors = neighbors Nothing (Just Alive) Nothing Nothing\r\n      }\r\n    , {from = Nothing\r\n      , to = Just Alive\r\n      , neighbors = neighbors Nothing Nothing (Just Alive) Nothing\r\n      }\r\n    , {from = Nothing\r\n      , to = Just Alive\r\n      , neighbors = neighbors Nothing Nothing Nothing (Just Alive)\r\n      }\r\n    ]\r\n\r\nAs one can tell, that example blew up. Thats because we did not use any symmetry.\r\n","type":"List.List CellAutomata.LifeLike.Rule -> CellAutomata.LifeLike.Automata"},{"name":"fullSymmetry","comment":" The position of the neighbors is not important, only the amount.\r\n","type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"},{"name":"noSymmetry","comment":" Every possible way the neighbors might be arranged needs its own rule.\r\n","type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"},{"name":"rot90Symmetry","comment":" Pattern may be rotated in 90,180 and 270 degree angles.\r\n","type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"},{"name":"step","comment":" This is the main function.  \r\nIt has a wierd type, but thats because it is meant to be used with Dict.update:\r\n\r\n    List.range 0 12\r\n    |> List.foldl\r\n        (\\x g ->\r\n            List.range 0 10\r\n            |> List.foldl\r\n                (\\y -> Dict.update (x,y) ((x,y) |> step automata grid))\r\n                g\r\n        )\r\n        grid\r\n","type":"CellAutomata.LifeLike.Automata -> CellAutomata.LifeLike.Grid -> CellAutomata.LifeLike.Location -> Maybe.Maybe CellAutomata.LifeLike.State -> Maybe.Maybe CellAutomata.LifeLike.State"}],"binops":[]}]