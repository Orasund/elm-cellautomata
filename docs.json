[{"name":"CellAutomata","comment":" If you are new to this package, consider checking out CellAutomata.LifeLike first,\nas it is written as an introduction to this module.\n\n**If you want to create cellAutomatas with more then one state,**  \n**but still operates on a 2D-Grid, than this package is the right one for you.**\n\nFirst start by writing your own state type.\nAs an example, lets try to simulate a ant that trys to escape a mase.\n* The ant will try to always follow right wall.\n\nOur state will now be the following\n\n    type State =\n        Wall,\n        Left,\n        Up,\n        Right,\n        Down\n# The Basics\n## Types\n@docs Order,Grid,Location\n\n## Rule\n@docs RuleExpression,Neighborhood,anyNeigborhood,Rule\n\n## Automata Without Symmetry\n@docs step,Automata,automataWithoutSymmetry\n\n# Symmetries\nNow that we need to specify our own state, it is no longer possible to write a\nfullSymmetry-Function(and it is not adviced to do so).\n\n## Symmetry\n@docs Symmetry,noSymmetry,horMirrorSymmetry,vertMirrorSymmetry,rot45Symmetry,rot90Symmetry\n\n## Automata\n@docs automata\n","unions":[{"name":"RuleExpression","comment":" RuleExpressions give us a very flexible way of talking about neighbors.\n\nSaying something is `Anything`, it means its value is ignored.\n","args":["state"],"cases":[]}],"aliases":[{"name":"Automata","comment":" The Automata type can be seen as a config type.  \nIts stores all information to specify the behaviour of a cell automata.  \nSometimes more then one automata should act on to the same Grid.  \nFor this reason it is its own type.\n","args":["state"],"type":"CellAutomata.General.Automata (CellAutomata.Neighborhood (Maybe.Maybe state)) (CellAutomata.Neighborhood (CellAutomata.RuleExpression (Maybe.Maybe state))) CellAutomata.Location state"},{"name":"Grid","comment":" The grid is the *model* of this module.\n\nYou might want to write your own view function for it\nor else you can't see what the automata has done.\n\nIn your head you should think of this as a grid, where some cells are filled in.  \nIn fact, only the filled cells are stored in the Dict.\n\nCells have the type `Maybe state` where `state` should be a custom type.\n(See CellAutomata.LifeLike for a idea of how the state may be implemented.)\n","args":["state"],"type":"Dict.Dict CellAutomata.Location state"},{"name":"Location","comment":" The location is the unique identifier for any cell.  \nFor our purpose we use `(x,y)`-coordinates.  \n\n**Note:** The south of `(0,0)` is `(0,y)` while the north is `(0,-y)`.\n","args":[],"type":"( Basics.Int, Basics.Int )"},{"name":"Neighborhood","comment":" The Neighborhood of a cell consists of the 8 surounding cells.\n\nIf some neighbor may have any value (that is most often the case),  \nits best to use the anyNeighborhood template and start from there.  \n","args":["state"],"type":"{ north : state, northEast : state, east : state, southEast : state, south : state, southWest : state, west : state, northWest : state }"},{"name":"Order","comment":" Every State needs a defined order.\n(e.g. a function that gives each state a unique identifer)\n\nFor example the order function for Langton's ant is the following.\n\n    order maybeState =\n        case maybeState of\n            Nothing -> 0\n            Just Wall -> 1\n            Just Up -> 2\n            Just Down -> 3\n            Just Left -> 4\n            Just Right -> 5\n","args":["state"],"type":"Maybe.Maybe state -> Basics.Int"},{"name":"Rule","comment":" A rule consist of the following elements:\n* **from** - the state of the cell\n* **neighbors** - the nessesary pattern of the neighbors\n* **to** - the state, the cell will transition in, if the rule applies\n","args":["state"],"type":"{ from : Maybe.Maybe state, neighbors : CellAutomata.Neighborhood (CellAutomata.RuleExpression (Maybe.Maybe state)), to : Maybe.Maybe state }"},{"name":"Symmetry","comment":" A symmetry is just a function that determines when a rule is sucessfully applied.\n","args":["state"],"type":"Maybe.Maybe state -> CellAutomata.Neighborhood (Maybe.Maybe state) -> CellAutomata.Rule state -> Basics.Bool"}],"values":[{"name":"anyNeigborhood","comment":" this template helps defining a Neighborhood.\n\nFor example, if we would want to only consider the north neighbor,\nwe might specify it the following way\n\n    {anyNeighborhood\n    | north : Exactly a\n    }\n","type":"CellAutomata.Neighborhood (CellAutomata.RuleExpression (Maybe.Maybe state))"},{"name":"automata","comment":" With this function we can now add our own symmetry.\n","type":"CellAutomata.Symmetry state -> CellAutomata.Order state -> List.List (CellAutomata.Rule state) -> CellAutomata.Automata state"},{"name":"automataWithoutSymmetry","comment":" This function uses no symmetry, this means every possible combination must be\nspecified.\n\n    automataWithoutSymmetry = automataWithCustomSymmetry noSymmetry\n\n**This function is not useful in practice.**  \n**Most often you want at least rotational or mirrored symmetry**  \n**This function is only included for demonstration purposes**\n\nCheckout CellAutomata.LifeLike for a more detailed discribtion.\n\nFor example the rules for Langton's ant are the following:\n* if a white cell is in front of\n","type":"CellAutomata.Order state -> List.List (CellAutomata.Rule state) -> CellAutomata.Automata state"},{"name":"horMirrorSymmetry","comment":" Pattern may be horizontally mirrored\n","type":"Maybe.Maybe state -> CellAutomata.Neighborhood (Maybe.Maybe state) -> CellAutomata.Rule state -> Basics.Bool"},{"name":"noSymmetry","comment":" Every possible way the neighbors might be arranged needs its own rule.\n","type":"Maybe.Maybe state -> CellAutomata.Neighborhood (Maybe.Maybe state) -> CellAutomata.Rule state -> Basics.Bool"},{"name":"rot45Symmetry","comment":" Pattern may be rotated in any position.\n","type":"Maybe.Maybe state -> CellAutomata.Neighborhood (Maybe.Maybe state) -> CellAutomata.Rule state -> Basics.Bool"},{"name":"rot90Symmetry","comment":" Pattern may be rotated in 90,180 and 270 degree angles.\n","type":"Maybe.Maybe state -> CellAutomata.Neighborhood (Maybe.Maybe state) -> CellAutomata.Rule state -> Basics.Bool"},{"name":"step","comment":" This is the main function.  \nIt has a wierd type, but thats because it is meant to be used with Dict.update:\n\n    List.range 0 12\n    |> List.foldl\n        (\\x g ->\n            List.range 0 10\n            |> List.foldl\n                (\\y -> Dict.update (x,y) ((x,y) |> step automata grid))\n                g\n        )\n        grid\n","type":"CellAutomata.Automata state -> CellAutomata.Grid state -> CellAutomata.Location -> Maybe.Maybe state -> Maybe.Maybe state"},{"name":"vertMirrorSymmetry","comment":" Pattern may be vertically mirrored\n","type":"Maybe.Maybe state -> CellAutomata.Neighborhood (Maybe.Maybe state) -> CellAutomata.Rule state -> Basics.Bool"}],"binops":[]},{"name":"CellAutomata.LifeLike","comment":" \nThis module was created to give a smooth introduction to the main module,  \nbut also because for a lot of use cases this simpler version is already enough.\n\n**If you know of Conway's Game of Life and want to make something similiar,**  \n**this module is the right one for you**\n\nIn this module, a few assumptions about the automata where made:\n* The cells are organiced in a two dimensional grid.\n* Each cell can have on of two states: *Dead*(`Nothing`) or *Alive*(`Just Alive`)\n* Each cell has eight neighbors\n* A rule can only take the amount of alive neighbored cells into account. (Not the pattern)\n\n**Note:** This last assumption can be ignored by using\n`automataWithoutSymmetry`(the exact pattern must the matched) \nor `automataWithCustomSymmetry`(for example mirrored or rotational symmetry).\n\n# The Basics\n## Basic Types\n@docs Grid,State,Location\n\n## Basic Automata\n@docs AliveNeighbors,step,Automata,automata\n\n# Rule Expressions and Symmetries\nUp until now, only the amound of living neighbors where important, but not their position.  \n\nFor the remaining documentation we use a modified version of game of life,  \nwhere only the four direct neighbors (North,South,East,West) are considered.  \n\n## Rule\n@docs RuleExpression,Neighborhood,anyNeigborhood,Rule\n\n## Automata\n@docs automataWithoutSymmetry\n\n## Symmetry\n@docs Symmetry,fullSymmetry,noSymmetry,horMirrorSymmetry,vertMirrorSymmetry,rot45Symmetry,rot90Symmetry\n\n## Automata with Symmetry\n@docs automataWithCustomSymmetry\n","unions":[{"name":"AliveNeighbors","comment":" This type specifies how many neighbors may be alive.\n","args":[],"cases":[["AllDead",[]],["OneAlive",[]],["TwoAlive",[]],["ThreeAlive",[]],["FourAlive",[]],["FiveAlive",[]],["SixAlive",[]],["SevenAlive",[]],["EightAlive",[]],["AnyAmount",[]]]},{"name":"RuleExpression","comment":" RuleExpressions give us a very flexible way of talking about neighbors.\n\nWhen writing a rule for the neighbors, they can now have one of the following values:  \n* **(Exactly <| Just Alive)** - its alive\n* **(Exactly <| Nothing)** - its dead\n* **Anything** - it may be dead or alive - we dont care.\n\n**Note:**\nIf you would go back to counting the alive neighbors, the `Anything`-expression will\nact like an optional neighbor.  \nFor example a rule that looks for 3 `Alive` and 2 `Anything`,  \nits will be successfull if it finds either 3,4 or 5 alive neighbors. \n","args":["state"],"cases":[]},{"name":"State","comment":" The State will specify all posible states a Cell can be in (besides a empty Cell)\n\nThis means cells will be of type `Maybe State`.  \nThis way its clear that, if not specified otherwise, a cell will be `Nothing`.  \nIn this module there is just one other state: `Just Alive`.  \nIf you want to add more states, then you should go to the main module.  \n","args":[],"cases":[["Alive",[]]]}],"aliases":[{"name":"Automata","comment":" The Automata type can be seen as a config type.  \nIts stores all information to specify the behaviour of a cell automata.  \nSometimes more then one automata should act on to the same Grid.  \nFor this reason it is its own type.\n","args":[],"type":"CellAutomata.General.Automata (CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State)) (CellAutomata.LifeLike.Neighborhood (CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State))) CellAutomata.LifeLike.Location CellAutomata.LifeLike.State"},{"name":"Grid","comment":" The grid is the *model* of this module.\n\nYou might want to write your own view function for it or else you can't see what the automata has done.\n\nIn your head you should think of this as a grid, where some cells are filled in.  \nIn fact, only the filled cells are stored in the Dict.  \nFilled cells have the value `Just Alive` while empty cells have the value `Nothing`.  \nThis is why we represent the grid as a dictionary.\n","args":[],"type":"Dict.Dict CellAutomata.LifeLike.Location CellAutomata.LifeLike.State"},{"name":"Location","comment":" The location is the unique identifier for any cell.  \nFor our purpose we use `(x,y)`-coordinates.  \n\n**Note:** The south of `(0,0)` is `(0,y)` while the north is `(0,-y)`.\n","args":[],"type":"( Basics.Int, Basics.Int )"},{"name":"Neighborhood","comment":" This replaces the `AliveNeighbors` type.\n\nInstead of saying \"one alive neighbor\", we now need to explicitly specify where\nthis neighbor is located.\n\nIf some neighbor may have any value (that is most often the case),  \nits best to use the anyNeighborhood template and start from there.  \n","args":["state"],"type":"{ north : state, northEast : state, east : state, southEast : state, south : state, southWest : state, west : state, northWest : state }"},{"name":"Rule","comment":" A rule now needs a Neighborhood instead of an `AliveNeighbors`-value.\n","args":[],"type":"{ from : Maybe.Maybe CellAutomata.LifeLike.State, neighbors : CellAutomata.LifeLike.Neighborhood (CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State)), to : Maybe.Maybe CellAutomata.LifeLike.State }"},{"name":"Symmetry","comment":" A symmetry is just a function that determines when a rule is sucessfully applied.  \nDuring this documentation we have already encountered two different symmetries:  \n`fullSymmetry` and `noSymmetry`.\n","args":[],"type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"}],"values":[{"name":"anyNeigborhood","comment":" this template helps defining a Neighborhood.\n\nFor example, if we would want to only consider the 4 adjacent neighbors,\nwe might specify it the following way\n\n    {anyNeighborhood\n    | north : Exactly a\n    , east : Exactly b\n    , south : Exactly c\n    , west : Exactly d\n    }\n","type":"CellAutomata.LifeLike.Neighborhood (CellAutomata.LifeLike.RuleExpression (Maybe.Maybe CellAutomata.LifeLike.State))"},{"name":"automata","comment":" The input is a list of rules.  \nAs an example, lets look at the rules for conway's game of life:\n* Alive cells survive if they have 2 or 3 alive neighbors, else they die.\n* Dead cells turn alive if exactly 3 neighbors are alive.\n\nImplemented, these rules look like this:\n\n    [ {from = Just Alive, neighbors = TwoAlive, to = Just Alive}\n    , {from = Just Alive, neighbors = ThreeAlive, to = Just Alive}\n    , {from = Just Alive, neighbors = AnyAmount, to = Nothing}\n    , {from = Nothing, neighbors = ThreeAlive, to = Just Alive}\n    ]\n\nThe order of the rules are important: the automata will go through the list,  \nand use the first use it can apply.\n","type":"List.List { from : Maybe.Maybe CellAutomata.LifeLike.State, neighbors : CellAutomata.LifeLike.AliveNeighbors, to : Maybe.Maybe CellAutomata.LifeLike.State } -> CellAutomata.LifeLike.Automata"},{"name":"automataWithCustomSymmetry","comment":" With this function we can now add our own symmetry.\n\nGoing back to the old example, this can now be done the following way:\n\n    [ {from = Just Alive\n      , to = Just Alive\n      , neighbors = neighbors (Just Alive) Nothing Nothing Nothing\n      }\n    , {from = Just Alive, to = Nothing, neighbors = anyNeighborhood}\n    , {from = Nothing\n      , to = Just Alive\n      , neighbors = neighbors (Just Alive) Nothing Nothing Nothing\n      }\n    ]\n        |> automataWithCustomSymmetry rot90Symmetry\n","type":"CellAutomata.LifeLike.Symmetry -> List.List CellAutomata.LifeLike.Rule -> CellAutomata.LifeLike.Automata"},{"name":"automataWithoutSymmetry","comment":" This function uses no symmetry, this means every possible combination must be\nspecified.\n\n    automataWithoutSymmetry = automataWithCustomSymmetry noSymmetry\n\n**This function is not useful in practice.**  \n**Most often you want at least rotational or mirrored symmetry**  \n**This function is only included for demonstration purposes**\n\nFor example, lets say we want to modify conway's game of life, such that\nit only considers the four adjacent neighbors:\n* Alive cells survive if they have exactly 1 adjacent neighbors\n* Dead cells turn alive if exactly 1 neighbors are alive\n\nThe implementation would be the following list:\n\n    let\n        neighbors a b c d = \n            {anyNeighborhood\n            | north : Exactly a\n            , east : Exactly b\n            , south : Exactly c\n            , west : Exactly d\n            }\n    in\n    [ {from = Just Alive\n      , to = Just Alive\n      , neighbors = neighbors (Just Alive) Nothing Nothing Nothing\n      }\n    , {from = Just Alive\n      , to = Just Alive\n      , neighbors = neighbors Nothing (Just Alive) Nothing Nothing\n      }\n    , {from = Just Alive\n      , to = Just Alive\n      , neighbors = neighbors Nothing Nothing (Just Alive) Nothing\n      }\n    , {from = Just Alive\n      , to = Just Alive\n      , neighbors = neighbors Nothing Nothing Nothing (Just Alive)\n      }\n    , {from = Just Alive, to = Nothing, neighbors = anyNeighborhood}\n    , {from = Nothing\n      , to = Just Alive\n      , neighbors = neighbors (Just Alive) Nothing Nothing Nothing\n      }\n    , {from = Nothing\n      , to = Just Alive\n      , neighbors = neighbors Nothing (Just Alive) Nothing Nothing\n      }\n    , {from = Nothing\n      , to = Just Alive\n      , neighbors = neighbors Nothing Nothing (Just Alive) Nothing\n      }\n    , {from = Nothing\n      , to = Just Alive\n      , neighbors = neighbors Nothing Nothing Nothing (Just Alive)\n      }\n    ]\n\nAs one can tell, that example blew up. Thats because we did not use any symmetry.\n","type":"List.List CellAutomata.LifeLike.Rule -> CellAutomata.LifeLike.Automata"},{"name":"fullSymmetry","comment":" The position of the neighbors is not important, only the amount.\n","type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"},{"name":"horMirrorSymmetry","comment":" Pattern may be horizontally mirrored\n","type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"},{"name":"noSymmetry","comment":" Every possible way the neighbors might be arranged needs its own rule.\n","type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"},{"name":"rot45Symmetry","comment":" Pattern may be rotated in any position.\n","type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"},{"name":"rot90Symmetry","comment":" Pattern may be rotated in 90,180 and 270 degree angles.\n","type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"},{"name":"step","comment":" This is the main function.  \nIt has a wierd type, but thats because it is meant to be used with Dict.update:\n\n    List.range 0 12\n    |> List.foldl\n        (\\x g ->\n            List.range 0 10\n            |> List.foldl\n                (\\y -> Dict.update (x,y) ((x,y) |> step automata grid))\n                g\n        )\n        grid\n","type":"CellAutomata.LifeLike.Automata -> CellAutomata.LifeLike.Grid -> CellAutomata.LifeLike.Location -> Maybe.Maybe CellAutomata.LifeLike.State -> Maybe.Maybe CellAutomata.LifeLike.State"},{"name":"vertMirrorSymmetry","comment":" Pattern may be vertically mirrored\n","type":"Maybe.Maybe CellAutomata.LifeLike.State -> CellAutomata.LifeLike.Neighborhood (Maybe.Maybe CellAutomata.LifeLike.State) -> CellAutomata.LifeLike.Rule -> Basics.Bool"}],"binops":[]}]